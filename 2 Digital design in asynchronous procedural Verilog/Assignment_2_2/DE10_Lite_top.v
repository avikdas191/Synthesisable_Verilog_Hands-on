//  This code was originally generated by Terasic System Builder
//  then amended by AK for brewity
`default_nettype none // disallow associting new names with wires
module DE10_Lite_top( 
// keep the ports declaration below and use these names in your design
	input 				ADC_CLK_10, MAX10_CLK1_50, MAX10_CLK2_50, 	// CLOCK
	output	[7:0] 	HEX0, HEX1, HEX2, HEX3, HEX4, HEX5, 		// SEG7, 6 pcs
	input		[1:0]		KEY,	// inverted push buttons, 2 pcs				
	output	[9:0]		LEDR,	// red LEDs, 10 pcs
	input 	[9:0]		SW	// slide switches, 10 pcs
);

//  do_not_remove_code BEGIN
	wire [1:0] KEYn = ~KEY; // KEYn is 1 when the button is pressed, use it
	assign LEDR = SW;
	
// END of do_not_remove_code

// all_your_HDL_code BEGIN
	// blank out the unused displays - comment the one YOU need to use (here HEX3)
//		assign HEX5 = 8'b_1111_1111;
		assign HEX4 = 8'b_1111_1111;
		assign HEX2 = 8'b_1111_1111;
		assign HEX3 = 8'b_1111_1111;
		assign HEX1 = 8'b_1111_1111;
		assign HEX0 = 8'b_1111_1111;
		
//		assign HEX3 = { 2 {SW[9:6]} }; // test pattern used to get the solution

	// declare a temporary 8 bits register to use within the always block, e.g. r_7LED
	
	// 1. write a definition of the asynchronous procedural block (2 lines)
	// 	2. then insert the case statement inside the procedural block as appropriate (2 lines)
	// 		3. then insert 16 case lines to drive the display for all the possible HEX digits inside the case statement
	//			(make sure that the decimal point (segment 7) is ON when the displayed value exceeds 9)
	// 		4. add the default line inside the case statement (blank out the display)

		
	// assign your display to be driven from the temporary register, e.g. assign HEX3 = r_7LED;
	
	reg [7:0] r_7LED; // for an LHS of the procedural block
	always @(*) begin // procedural block to use case
	// strictly speaking begin..end is not required for a single
	// statement but it is a good practice to put it anyway
		case ( SW[6:3] )
			// value â€“ either bit slice or bit concatenation
			4'b0000: r_7LED = 8'b_1_100_0000;	// for 0
			4'b0001: r_7LED = 8'b_1_111_1001;	// for 1
			4'b0010: r_7LED = 8'b_1_010_0100;	// for 2
			4'b0011: r_7LED = 8'b_1_011_0000;	// for 3 
			4'b0100: r_7LED = 8'b_1_001_1001;	// for 4 
			4'b0101: r_7LED = 8'b_1_001_0010;	// for 5 
			4'b0110: r_7LED = 8'b_1_000_0010;	// for 6 
			4'b0111: r_7LED = 8'b_1_111_1000;	// for 7 
			4'b1000: r_7LED = 8'b_1_000_0000;	// for 8 
			4'b1001: r_7LED = 8'b_1_001_0000;	// for 9 
			4'b1010: r_7LED = 8'b_0_000_1000;	// for A 
			4'b1011: r_7LED = 8'b_0_000_0011;	// for B 
			4'b1100: r_7LED = 8'b_0_100_0110;	// for C 
			4'b1101: r_7LED = 8'b_0_010_0001;	// for D 
			4'b1110: r_7LED = 8'b_0_000_0110;	// for E 
			4'b1111: r_7LED = 8'b_0_000_1110;	// for F 
			default: r_7LED = 8'b_1_111_1111;	// blank
			
			// strictly not required here as all the cases are
			// to be covered but again a good practice
		endcase
	end
	assign HEX5 = r_7LED; // to drive the output port
	
// END of all_your_HDL_code

endmodule
